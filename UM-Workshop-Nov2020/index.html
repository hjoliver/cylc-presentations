<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Cylc 8 Nov 2020</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/hjo.css" id="theme">
		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/school-book.css" id="highlight-theme">
		<style>
section {
		color: slategray;
}
code {
	 color:darkseagreen;
	 font-weight:bold;
}
span.quote {
	 color:orange;
}
span.quotebold {
	 color:darkorange;
}
	
		</style>

	</head>
	<body>
	<div class="reveal">
		 <div class="slides">

				<section>
					 <section>
							<h1>
								 Cylc 8 Project Report
							</h1>
							<h2>
									UM Workshop
									Nov 2020
							</h2>
							<p>Hilary Oliver, NIWA</p>
							<aside class="notes">
							</aside>
					</section>
			</section>

			<section>
					 <section>
							 <ul>
									 <li> recap: why is Cylc changing?
									 <li> what's not changing?
									 <li> what is changing?
									 <li> when will it change?
							 </ul>
							<aside class="notes">
							 why? - reminder!
							</aside>
	  			 </section>
			 </section>
	
			<section>
					 <section>
							 <h2>why is cylc<br/>
									 changing?</h2>
					 </section>
	
					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/python2-gtk.png"/>
							</div>
							<!--
							Python 2 RIP image credit: datree.io
							-->
							<aside class="notes">
							<ul>
									<li>Cylc 7 scheduler and CLI are Python 2 based
									<li>Cylc 7 GUI is a Python 2 PyGTK desktop application
									   (several years FTE in it)
									<li>Python 2 is now 10 months past EOL
									<li>PyGTK is obsolete - no Python 3 version
							</ul>
							</aside>
					</section>
	
					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/evolution.jpg"/>
							</div>
							<!--
							image credit: Harvard Gazette
							-->
							<aside class="notes">

							<p>Cylc has evolved organically over more than 10 years now.
							Consequently it has accumulated "technical debt" and has some
							serious design flaws that need addressing if it is to remain
							fit-for-purpose as demands on it continue to increase. Cylc 7
							is pretty well optimized but in many ways (scheduling algorithm,
							GUI and network latyer) it is reaching its limits in current
							massive workflows.
							The security model is also considered bespoke and quirky by
							security people, and that was becoming increasingly problematic.
							</p>

							<p>
							NOW the minimal solution was migrate to Python 3 and rewrite the
							GUIs in modern desktop GUI toolkit. But that would not address
							most of the aforementioned problems, AND besides all stakeholders
							wanted more than that. Chiefly, a web UI to allow proper remote
							access and integrate with site identity management. But that 
							had architectural implications, and also required solving some of
							the bigger problems.
							</p>

							</aside>
					</section>
			</section>
	
			<section>
					 <section>
							 <h2>what's <span style="color:red">not</span><br/> changing?</h2>
					 </section>

					 <section>
					 <ul>
							 <li> no barrier between cycles
							 <span style="font-size:50%">(our original raison
									 d'etre)</span></li>
							 <li> support for Cylc 7 <code>suite.rc</code>
							 <span style="font-size:50%">(with deprecations)</span></li>
							 <li> support for Cylc 7 CLI syntax 
							 <span style="font-size:50%">(with deprecations)</span></li>
							 <li> all core Cylc 7 functionality
							 <span style="font-size:50%">(supported by tests)</span><br/>
							 <span style="font-size:80%">(kept or replaced with minimal impact on users)</span></li>
					 </ul>
					 <aside class="notes">
							 core: xtriggers, event handling, all control functionality (in
							 general terms, if not in detail or implementation)
					 </aside>
					 </section>

					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/cycling-1.png"/>
							</div>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img class="fragment" src="hjo/media/cycling-2b0.png"/>
							</div>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img class="fragment" src="hjo/media/cycling-2b00a.png"/>
							</div>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img class="fragment" src="hjo/media/cycling-2b000a.png"/>
							</div>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img class="fragment" src="hjo/media/cycling-2b000b.png"/>
							</div>
							<!--
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img class="fragment" src="hjo/media/cycling-2b00.png"/>
							</div>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img class="fragment" src="hjo/media/cycling-2b000.png"/>
							</div>
							-->
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img class="fragment" src="hjo/media/cycling-2b.png"/>
							</div>
	
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img class="fragment" src="hjo/media/cycling-2.png"/>
							</div>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img class="fragment" src="hjo/media/cycling.png"/>
							</div>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img class="fragment" src="hjo/media/cycling-running.png"/>
							</div>
							<aside class="notes">
									<p>A remember of our core cycling functionality, which is
									relevant later:</p>
								 <p>Cylc unwinds the cycle loop and gives each task its own
								 cycle point label, to create <b>a single potentially INFINITE
										workflow composed of repeating tasks</b> instead of a
								 sequence of distinct single cycle workflows. So that's an
								 interesting new form of scaling!</p>
							</aside>
					 </section>
			 </section>

			<section>
					 <section>
							 <h2>what <span style="color:red">IS</span><br/> changing?</h2>
					 </section>

					 <section>
							<h4>what's changing (1/4)</h4>
					 <ul>
							 <li class="fragment"> <span class="quotebold">new architecture:</span>
							 <ul>
									 <li> <span class="quote">components:</span>Hub,  web UI, UI Server, Scheduler, CLI</li>
									 <li> <span class="quote">network:</span> Protobuf, ZeroMQ, Tornado, GraphQL, WebSocket</li> 
							 </ul></li>
							 <li class="fragment"><span class="quotebold"> web UI</span>
							 <ul>
									 <li> integrated "gscan"</li>
									 <li> responsive design: desktop to mobile</li>
									 <li> shared datastore and incremental update</li>
							 </ul></li>
						</ul>
						</section>

					 <section>
							<h4>what's changing (2/4)</h4>
					 <ul>
							 <li> <span class="quotebold">new "spawn on demand" scheduler</span>
							 <ul>
									 <li> efficient, scalable (real task pool limiting!)</li>
									 <li> no suicide triggers for path branching</li>
									 <li> no implicit dep on prev task.cycle submit <ul>
											 <li> task.cycle instances can run out of order</li>
											 <li> no unnecessary stall below failed tasks</li>
									 </ul></li>
									 <li> allows a graph-based "window on the workflow" with no
									 leakage of <em>task pool</em> internals into user space
									 <br/>(e.g. no <code>cylc insert</code>)</li>
							 </ul></li>
					 </ul>
					 <aside class="notes">
							in Cylc 7 the task pool bloat is the major performance limiting
							factor in huge suites (the tasks in the infinite graph that cylc
							has to maintain an awareness of: runahead limiting only limits
							the task pool across cycles, not within a cycle. Queue limiting
							limiting active tasks (protecting external resources) but not the
							internal task pool.

							complex suite with 1000 tasks/per cycle : runs with max 10
							active


					 </aside>
					 </section>

					 <section>
							<h4>what's changing (3/4)</h4>

					 <ul>
							<ul>
								 <li class="fragment"> <code>rose suite-run+</code> migrated to Cylc
							<ul>
								 <li> <span class="quote">platforms</span> support</li>
								 <li> <span class="quote">suite install</span> (src to run-dir; job hosts)</li>
								 <li>  <span class="quote">safe suite run semantics</span>
								 <ul>
										 <li> play, pause, resume (and reflow)</li>
										 <li> new run-dir for each new install/run</li>
								 </ul></li>
						 </ul> </li>

						 <li class="fragment"> <span class="quote">terminology and filenames</span>
						 <ul>
								 <li> suite -&gt; (work)flow
								 <li> <code>suite.rc</code> -&gt; <code>flow.cylc</code>
						 </ul></li>

						</ul>
					 <aside class="notes">
							 cylc play etc.: c.f. cylc run (cold or warm start), restart,
							 hold, release; with "run" destructively overwriting files in
							 existing run-dir and preventing subsequent restart
					 </aside>
	
						</section>

					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/cise-cylcpage.png"/>
							</div>
							<div style="position:absolute; top:0; right:0"><strong>CiSE 2019</strong></div>
					 </section>

						<section>
							<h4>what's changing (4/4)</h4>
						<ul>
							 <li class="fragment"> migration to Python 3</li>
							 <li class="fragment"> code management: 6+ repositories (was 1)</li>
							 <li class="fragment"> packaging: <code>conda install cylc</code></li>
							 <li class="fragment"> cylc plugins</li>
							 <li class="fragment"> documentation (arggh)</li>
							 <li class="fragment"> authentication (user and job)</li>
							 <li class="fragment"> fine-grained authorization</li>
							 <li class="fragment"> ...</li>
					 </ul>
					 <aside class="notes">
							<ul>
								 <li> authentication: users and jobs	
								  <li> states: OLD 13 task/job states. NEW 5 task/job states 3
									<ul>
										 <li> submitted, submit-failed, running, succeeded, failed
										 <li> waiting, preparing, expired
									</ul>
								 <li> internals: e.g. self-documenting config classes linked to
								 the user guide build
							</ul>
					 </aside>
					 </section>
		 </section>

		 <section>
				 <section>
						 <h2>Cylc web UI<br/> &amp; Cylc TUI</h2>
				 </section>
				 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/cylc-ui-demo.gif"/>
							</div>
					 </section>
  				 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/cylc-ui-1.gif"/>
							</div>
					 </section>
	
  				 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/cylc-ui-mutations.gif"/>
							</div>
					 </section>
	
					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/cylc-tui-demo.gif"/>
							</div>
					 </section>
			 </section>

		 <section>
					 <section>
							 <h2>Spawn on<br/> Demand</h2>
					 </section>

					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/SoS.png"/>
							</div>
					 </section>
					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/SoD.png"/>
							</div>
							<aside class="notes">
								 the "task pool": Python objects that represent the tasks in
								 the infinite graph that the scheduler has to be aware of at
								 this point in time.
								 <ul>
										<li> small suite: 4 tasks per cycle
										<li> Cylc 0-7: at least one running or waiting cycle-point
										instance of every task in the suite, PLUS all succeeded
										tasks in the current window .
										<ul>
											 <li> in this example, active tasks (green) spread of 5
											 cycle points: task pool 16 (but up to 20 or more)
										</ul>
										<li> Cylc 8: task pool 3!! (actually 2, blue not necessary
										here - just to show runhead limited waiting task)
								 </ul>

							</aside>
					 </section>

					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/n-dist-1.svg"/>
							</div>
					 </section>
					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/n-dist-2.svg"/>
							</div>
					 </section>
					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/n-dist-3.svg"/>
							</div>
					 </section>
					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/n-dist-4.svg"/>
							</div>
					 </section>
					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/n-dist-5.svg"/>
							</div>
							<aside class="notes">
									- n=0 (active): submitted, running, (or unhandled-failed)
									- n=1: what comes next, including ready-but-held-back tasks
									- makes graph view useful even in very large suites
									- the rationale behind what you see in the UI makes sense
							</aside>
					 </section>




					 <section>
							<div style="width:100%; position:absolute; left:0; top:0"/>
								 <img src="hjo/media/suicide.png"/>
							</div>
					 </section>
	
					 <section>
						<pre><code class="ini">[scheduling]  # Cylc 7
   cycling mode = integer
   initial cycle point = 1
   [[dependencies]]
      [[[P1]]]
         graph = """
            pre => model
            model:fail => diagnose => recover
            model | recover => post
            model => !diagnose & !recover  # ???
         """
</code></pre>
</section>
					 <section>
						<pre><code class="ini">[scheduling]  # Cylc 8
   cycling mode = integer
   initial cycle point = 1
   [[graph]]
      P1 = """
         pre => model
         model:fail => diagnose => recover
         model | recover => post
      """
</code></pre>
</section>

					 <!-- ANIM: MUST BE FOLLOWED BY data-state=postanim (PAUSE WORKFLOW) -->
					 <section data-state="anim-2">
					<div style="position:absolute; top:100px; right:0">
							<span style="font-size:50%">Cylc 8: spawn-on-demand</span>
					</div>
							<div id="infinite-cycling-2" style="width:900px; height:700px; border: 1px dashed slategray;">
							</div>
							<span style="font-size:10px; position:absolute; bottom:0; left:0">Credit: Oliver Sanders</span>
							<aside class="notes">
					 </section>

					 <!-- POSTANIM2: PAUSE WORKFLOW ON MOVE TO NEXT SLIDE -->
					 <section data-state="anim-3 postanim-2">
							<div style="position:absolute; top:100px; right:0">
									<span style="font-size:50%">Cylc 8: spawn-on-demand<br/>REFLOW</span>
							</div>
	
							<div id="infinite-cycling-3" style="width:900px; height:700px; border: 1px dashed slategray;">
							</div>
							<span style="font-size:10px; position:absolute; bottom:0; left:0">Credit: Oliver Sanders</span>
							<aside class="notes">
									<p>
									multiple workflow wavefronts, if you like, traveling through
									the infinite graph. A new front can be triggered simply by
									triggering the task or tasks at the head of it.
									</p>
							</aside>
					</section>
			</section>

		 <section>
				 <!-- POSTANIM3: PAUSE WORKFLOW ON MOVE TO NEXT SLIDE -->
				 <section data-state="postanim-3">
						 <h2><span style="color:red">When</span> Cylc 8.0.0?</h2>
				 </section>

				 <section style="font-size:80%">
						 <h4>done already</h4>
						 <ul>
								 <li>Python 3 migration</li>
								 <li>architecture: new components and network layers </li>
								 <li>Hub spawns Cylc UI Servers (JupyterHub!)</li>
								 <li>web UI core (Vue.js) and tree view</li>
								 <li>incremental data update subscriptions</li>
								 <li>spawn-on-demand scheduler</li>
								 <li>secure back-end job authentication (CurveZMQ)</li>
								 <li>packaging via <code>pip</code> and <code>conda</code></li>
								 <li>platforms support</li>
								 <li>suite installation to job platforms</li>
								 <li>many config changes</li>
						 </ul>
				 </section>

				 <section style="font-size:80%">
						 <h4>still to be done</h4>
						 <ul>
								 <li>Cylc UI:
								 <ul>
										 <li>finish UI command integration</li>
										 <li>display non-task entities (xtriggers, queues, ...)</li>
										 <li>new graph view</li>
										 <li>start stopped suites</li>
								 </ul>
								 <li>suite installation and new `cylc run` semantics<br/>
								 (with plugin for `rose-suite.conf` back-compat)</li>
								 <li>finish graph-based windowing (scheduler and UIS)
								 <ul>
										 <li>including loading historical tasks from the DB</li>
								 </ul></li>
								 <li>cross-user access and fine-grained authorization</li>
								 <li>documentation rewrite</li>
								 <li>cylc review (rose bush) fallback?</li>
								 <li>... and a million details</li>
						 </ul>
				 </section>

				 <section style="font-size:80%">
						 <h4>timeline</h4>
						 <p>we are behind schedule (team size, pandemic, ...) but:</p>
						 <br/>
						 <ul>
								 <li> first beta release <code>cylc-8.0b0</code> Jan 2021??
								 <ul>
										 <li>some non-critical features missing (e.g. UI graph view)</li>
										 <li>we will encourage heavy testing at this point</li>
								 </ul></li>
								 <br/>
								 <li> first full release <code>cylc-8.0</code> late Q2 2021?</li>
						 </ul>
						 <aside class="notes">
								 "critical" vs essential!
								 Graph view is essential to Cylc, but not critical because you
								 can run any workflow perfectly well without it

								 Note we are going as fast as we possibly can.
						 </aside>
				 </section>

	
		 </section>

		 <section>

					 <section>
							 <h4>thanks to the Cylc team</h4>
								 <img src="hjo/media/mug-shots.png"/>
								 <br/>
								 <span style="font-size:50%">(plus former members and
										 contributors too)</span>
					 </section>
		 </section>

		 </div>
	</div>


		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/fullscreen/plugin.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
                hash: true,
								width: 960,
                height: 800,
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealFullscreen ],
				transition:'none',
			});
		</script>
		
		<script>
      Reveal.on('beer', event => {
							count_down();
      }, false);


       function count_down() {
					// Set the date we're counting down to
					var countDownDate = new Date().getTime() + 45*60000;
					// Update the count down every 1 second
					var x = setInterval(function() {
									var now = new Date().getTime();
									// Find the distance between now and the count down date
									var d = countDownDate - now;
									// Time calculations for days, hours, minutes and seconds
									var min = Math.floor((d % (1000 * 60 * 60)) / (1000 * 60));
									var sec = Math.floor((d % (1000 * 60)) / 1000);
									// Display the result in the element with id="cdown"
									document.getElementById("cdown").innerHTML = min.toString().padStart(2, "0") + ":" + sec.toString().padStart(2,"0");
									}, 1000);
			}
		</script>

		<script src="hjo/js/minicylc.js"></script>
	  <script type="text/javascript" src="hjo/js/jquery.min.js"></script>

		<script>

      // write dependencies
      const deps = [];
      for (let i=0; i<100; i++) {
        deps.push(`a${i} => c${i} => d${i}`);
        deps.push(`a${i} => b${i}`);
        deps.push(`a${i} => a${i+1}`);
        deps.push(`c${i} => b${i+1}`);
      }

      // create graph
      const infinite_animation = $('<embed style="background:#eaeaea;"/>')
        .addClass('minicylc')
        .data('focus', true)
        .data('randomFactor', 0.5)
        .data('dependencies', deps.join('//'))
        .attr('src', 'hjo/media/infinite-workflow.svg')[0]
      $('#infinite-cycling').append(infinite_animation);

      const infinite_animation_2 = $('<embed style="background:#eaeaea;"/>')
        .addClass('minicylc')
        .data('focus', true)
        .data('randomFactor', 0.5)
        .data('dependencies', deps.join('//'))
				.data('succeed_fill', 'white')
        .attr('src', 'hjo/media/infinite-workflow.svg')[0]
      $('#infinite-cycling-2').append(infinite_animation_2);

      const infinite_animation_3 = $('<embed style="background:#eaeaea;"/>')
        .addClass('minicylc')
        .data('focus', true)
        .data('randomFactor', 0.5)
        .data('dependencies', deps.join('//'))
				.data('succeed_fill', 'white')
				.data('reflow', 'a7')
        .attr('src', 'hjo/media/infinite-workflow.svg')[0]
      $('#infinite-cycling-3').append(infinite_animation_3);


			const infinite_worklow = undefined
			const infinite_worklow_2 = undefined
			const infinite_worklow_3 = undefined

      Reveal.on('anim', event => {
						console.log(event);
						if (typeof infinite_workflow === 'undefined') {
							 infinite_workflow = new MiniCylc(infinite_animation, true);
							 infinite_workflow.run();
						}
						infinite_workflow.release();
      }, false);

      Reveal.on('postanim', event => {
						infinite_workflow.hold();
						}, false);

      Reveal.on('anim-2', event => {
						if (typeof infinite_workflow_2 === 'undefined') {
							 infinite_workflow_2 = new MiniCylc(infinite_animation_2, true);
							 infinite_workflow_2.run();
						}
						infinite_workflow_2.release();
      }, false);

      Reveal.on('postanim-2', event => {
						infinite_workflow_2.hold();
						}, false);

      Reveal.on('anim-3', event => {
						if (typeof infinite_workflow_3 === 'undefined') {
							 infinite_workflow_3 = new MiniCylc(infinite_animation_3, true);
							 infinite_workflow_3.run();
						}
						infinite_workflow_3.release();
						}, false);

      Reveal.on('postanim-3', event => {
						infinite_workflow_3.hold();
						}, false);

     </script>
		
	</body>
</html>
